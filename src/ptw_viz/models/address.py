"""
Address models for ARM v9 page table walk simulation.

This module defines the address types used in ARM v9 2-stage translation:
- VirtualAddress (VA): The address generated by the CPU
- IntermediatePhysicalAddress (IPA): Output of Stage 1 translation
- PhysicalAddress (PA): Final physical address after Stage 2 translation

For a 4KB granule with 48-bit virtual address:
    VA bits [47:39] → Level 0 index (9 bits, 512 entries)
    VA bits [38:30] → Level 1 index (9 bits, 512 entries)
    VA bits [29:21] → Level 2 index (9 bits, 512 entries)
    VA bits [20:12] → Level 3 index (9 bits, 512 entries)
    VA bits [11:0]  → Page offset (12 bits, 4KB page)
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional

from ptw_viz.models.granule import (
    GranuleConfig,
    GranuleType,
    get_granule_config,
    calculate_index,
    calculate_page_offset,
    calculate_block_offset,
    get_offset_mask,
    GRANULE_4KB_CONFIG,
)


# Legacy constants for backward compatibility (4KB granule)
GRANULE_4KB_SHIFT = 12
GRANULE_4KB_SIZE = 4096
INDEX_BITS = 9
INDEX_MASK = 0x1FF
LEVEL_0_START = 39
LEVEL_1_START = 30
LEVEL_2_START = 21
LEVEL_3_START = 12
PAGE_OFFSET_MASK = 0xFFF


@dataclass(frozen=True)
class VirtualAddress:
    """
    Represents a Virtual Address (VA) in ARM v9 architecture.

    The VA is the address generated by the processor when software performs
    a memory access. It is the input to Stage 1 translation.

    Attributes:
        value: The 64-bit virtual address value.
        va_bits: Number of VA bits (typically 48).
        granule_kb: Granule size in KB (4, 16, or 64).
    """

    value: int
    va_bits: int = 48
    granule_kb: int = 4

    @property
    def _config(self) -> GranuleConfig:
        """Get the granule configuration."""
        return get_granule_config(self.granule_kb)

    def __post_init__(self) -> None:
        """Validate the virtual address value."""
        if self.value < 0:
            raise ValueError(f"Virtual address cannot be negative: {self.value}")

    @property
    def l0_index(self) -> int:
        """Extract Level 0 table index."""
        return calculate_index(self.value, 0, self._config)

    @property
    def l1_index(self) -> int:
        """Extract Level 1 table index."""
        return calculate_index(self.value, 1, self._config)

    @property
    def l2_index(self) -> int:
        """Extract Level 2 table index."""
        return calculate_index(self.value, 2, self._config)

    @property
    def l3_index(self) -> int:
        """Extract Level 3 table index."""
        return calculate_index(self.value, 3, self._config)

    @property
    def page_offset(self) -> int:
        """Extract page offset."""
        return calculate_page_offset(self.value, self._config)

    @property
    def l1_block_offset(self) -> int:
        """Extract L1 block offset."""
        return calculate_block_offset(self.value, 1, self._config)

    @property
    def l2_block_offset(self) -> int:
        """Extract L2 block offset."""
        return calculate_block_offset(self.value, 2, self._config)

    def get_index(self, level: int) -> int:
        """Get the table index for a specific level."""
        return calculate_index(self.value, level, self._config)

    def uses_ttbr1(self) -> bool:
        """
        Determine if this VA uses TTBR1 (upper address range).

        In ARM, the upper half of the virtual address space (where bit
        va_bits-1 is set) uses TTBR1_EL1. The lower half uses TTBR0_EL1.

        Returns:
            True if this VA is in the TTBR1 range.
        """
        return (self.value >> (self.va_bits - 1)) & 1 == 1

    def to_hex(self) -> str:
        """Return the address as a hexadecimal string."""
        return f"0x{self.value:016X}"

    def __str__(self) -> str:
        return (
            f"VA({self.to_hex()}) -> "
            f"L0:{self.l0_index:#05x} L1:{self.l1_index:#05x} "
            f"L2:{self.l2_index:#05x} L3:{self.l3_index:#05x} "
            f"Offset:{self.page_offset:#05x}"
        )


@dataclass(frozen=True)
class IntermediatePhysicalAddress:
    """
    Represents an Intermediate Physical Address (IPA) in ARM v9 architecture.

    The IPA is the output of Stage 1 translation. In a virtualized system:
    - The guest OS thinks the IPA is the physical address
    - The hypervisor uses Stage 2 translation to convert IPA to PA

    Attributes:
        value: The 64-bit intermediate physical address value.
        ipa_bits: Number of IPA bits (typically 48 or 56).
        granule_kb: Granule size in KB (4, 16, or 64).
    """

    value: int
    ipa_bits: int = 48
    granule_kb: int = 4

    @property
    def _config(self) -> GranuleConfig:
        """Get the granule configuration."""
        return get_granule_config(self.granule_kb)

    def __post_init__(self) -> None:
        """Validate the intermediate physical address value."""
        if self.value < 0:
            raise ValueError(f"IPA cannot be negative: {self.value}")
        max_ipa = (1 << self.ipa_bits) - 1
        if self.value > max_ipa:
            raise ValueError(
                f"IPA {self.value:#x} exceeds maximum for {self.ipa_bits}-bit IPA"
            )

    @property
    def l0_index(self) -> int:
        """Extract Level 0 table index for Stage 2 walk."""
        return calculate_index(self.value, 0, self._config)

    @property
    def l1_index(self) -> int:
        """Extract Level 1 table index for Stage 2 walk."""
        return calculate_index(self.value, 1, self._config)

    @property
    def l2_index(self) -> int:
        """Extract Level 2 table index for Stage 2 walk."""
        return calculate_index(self.value, 2, self._config)

    @property
    def l3_index(self) -> int:
        """Extract Level 3 table index for Stage 2 walk."""
        return calculate_index(self.value, 3, self._config)

    @property
    def page_offset(self) -> int:
        """Extract page offset."""
        return calculate_page_offset(self.value, self._config)

    @property
    def l1_block_offset(self) -> int:
        """Extract L1 block offset."""
        return calculate_block_offset(self.value, 1, self._config)

    @property
    def l2_block_offset(self) -> int:
        """Extract L2 block offset."""
        return calculate_block_offset(self.value, 2, self._config)

    def get_index(self, level: int) -> int:
        """Get the table index for a specific level."""
        return calculate_index(self.value, level, self._config)

    def to_hex(self) -> str:
        """Return the address as a hexadecimal string."""
        return f"0x{self.value:016X}"

    def __str__(self) -> str:
        return f"IPA({self.to_hex()})"


@dataclass(frozen=True)
class PhysicalAddress:
    """
    Represents a Physical Address (PA) in ARM v9 architecture.

    The PA is the final output of the 2-stage translation process. It is
    the actual address used to access physical memory.

    With FEAT_D128, PAs can be up to 56 bits.

    Attributes:
        value: The 64-bit physical address value.
        pa_bits: Number of PA bits (up to 56 with FEAT_D128).
    """

    value: int
    pa_bits: int = 56

    def __post_init__(self) -> None:
        """Validate the physical address value."""
        if self.value < 0:
            raise ValueError(f"PA cannot be negative: {self.value}")
        max_pa = (1 << self.pa_bits) - 1
        if self.value > max_pa:
            raise ValueError(
                f"PA {self.value:#x} exceeds maximum for {self.pa_bits}-bit PA"
            )

    @property
    def page_offset(self) -> int:
        """Extract page offset."""
        return self.value & PAGE_OFFSET_MASK

    def to_hex(self) -> str:
        """Return the address as a hexadecimal string."""
        return f"0x{self.value:016X}"

    def __str__(self) -> str:
        return f"PA({self.to_hex()})"


def calculate_descriptor_address(
    table_base: int,
    index: int,
    descriptor_size: int = 8
) -> int:
    """
    Calculate the address of a descriptor within a translation table.

    The descriptor address is: table_base + (index * descriptor_size)

    For standard 64-bit descriptors, size is 8 bytes.
    For FEAT_D128 128-bit descriptors, size is 16 bytes.

    Args:
        table_base: Base address of the translation table.
        index: Index into the table (0-511 for 4KB granule).
        descriptor_size: Size of each descriptor in bytes (8 or 16).

    Returns:
        The address of the descriptor.
    """
    return table_base + (index * descriptor_size)
